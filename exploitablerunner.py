# 功能：生成gdb-exploitable分析的结果输出到GDB_OUTPUT文件中
import sys
import subprocess
import re
import os
import time
import shutil
import shlex        # shlex 模块最常用的是 split() 函数，用来分割字符串，通常与 subprocess 结合使用
import traceback
from paraData import dataset

def gdbAnalysis(exe_flie,openfilename,GDB_OUTPUT_FOLDER):
    # exe_flie: cflow 目标可执行程序绝对路径
    # openfilename: crasheslist.txt所在绝对路径(crashes文件夹与list在一起)
    # GDB_OUTPUT_FOLDER = sys.argv[3]  # 输出目录 : ../project/AnalysisOutput/GDB_OUTPUT/fuzzerName/program/program_X_Y
    print('exefile:',exe_flie)
    print("openfilename:",openfilename)
    print("GDB_OUTPUT_FOLDER:",GDB_OUTPUT_FOLDER)

    exe_flie_path = '/'.join(exe_flie.split('/')[:-1]) + '/'
    progcmd = {
        i[1]: ("gdb -ex 'r {CMD}' -ex 'exploitable' -ex 'bt' -ex 'quit' " + exe_flie_path + '/{NAME}').format(CMD=i[2],
                                                                                                              ID=i[0],
                                                                                                              NAME=i[1])
        for i in dataset}

    T = -1
    N = 0       # M N is input data  , T%M != N ,   N = 1 .M=30
    M = 1       # 选择指定数量(编号)的 文件路径

    exe_flie_name = exe_flie.split('/')[-1]  # exe_flie_name====prog   jhead

    if not os.path.exists(GDB_OUTPUT_FOLDER):  # GDB输出文件夹不存在则创建
        os.makedirs(GDB_OUTPUT_FOLDER, exist_ok=True)
    if not os.path.exists(os.path.dirname(GDB_OUTPUT_FOLDER) + '/tmp'):  # 临时文件夹不存在则创建   ......GDB/jhead/tmp
        os.makedirs(os.path.dirname(GDB_OUTPUT_FOLDER)  + '/tmp', exist_ok=True)
    x = None
    total_lines = len(open(openfilename).readlines())
    for line in open(openfilename):  # read lines of crasheslist.txt
        try:
            T += 1
            if T % M != N:  # confirm T value
                continue

            dupN= 0
            prog = exe_flie.split('/')[-1].split('_')[0]  # 可执行程序名称  jhead
            print('crash编号:', T + 1,' '+line)

            line_crashes = line.split("/")[-1].split('\n')[0]  # 崩溃文件名称:     id:000195,sig:11,src:001320,op:MOpt-core-havoc,rep:16
            if os.path.exists(os.path.join(GDB_OUTPUT_FOLDER, line_crashes+ ".stdout")):
                continue
            # tmpfile: GDB tmp  file  存放临时文件tmp  /home/jacky/Desktop/hp_ubuntu_desktop/output/fuzz_cflow
            print("path:", os.path.join(os.path.dirname(GDB_OUTPUT_FOLDER), 'tmp', "gdb_{prog}_cur_{N}".format(**locals())))
            # breakpoint('stop')
            # 将源文件的内容复制到目标文件或目录   临时文件作用：复制一个崩溃文件，防止污染
            tmpfile = shutil.copy(line.split('\n')[0] , os.path.join(os.path.dirname(GDB_OUTPUT_FOLDER),'tmp', "gdb_{prog}_cur_{N}".format(**locals())))
            cmd = shlex.split(progcmd[prog].replace("@@", tmpfile))
            print('CMD: ',cmd)
            starttime = time.time()

            try:
                x = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                   timeout=10)  # 我需要执行一个gdb字符串列表，并且在它周围有一个超时机制，这样当超时发生时，执行就会停止
            except subprocess.TimeoutExpired as e:
                # print("[timeout]", line)
                print(e.stdout)
                print("=============")
                # print(e.stderr)
                # print("=============")
                err = e.stdout.decode(errors="ignore") + "\n" + e.stderr.decode(errors="ignore")

                if "\nShort description: " in err:  # 文件读取Short description字段内容
                    ## record err to GDB_OUTPUT_FOLDER
                    if not os.path.isdir( GDB_OUTPUT_FOLDER):  # GDBOutput/jhead/jhead_1_0/
                        os.makedirs(GDB_OUTPUT_FOLDER, exist_ok=True)
                    with open(os.path.join(GDB_OUTPUT_FOLDER , line_crashes + ".stdout"), "wb") as errfp:
                        errfp.write(e.stdout)
                    with open(os.path.join(GDB_OUTPUT_FOLDER , line_crashes + ".stderr") , "wb") as errfp:
                        errfp.write(e.stderr)
                    open(os.path.join(GDB_OUTPUT_FOLDER , line_crashes + ".timeouted"), "wb").write(b'1')
                # with open("gdbtimeout_{fuzzername}_{prog}.log".format(**locals()), "a") as tmp:
                #    tmp.write(line+"\n")
                print(' =======================[timeout file writing] =============================')
                continue
            endtime = time.time()
            runtime = endtime - starttime
            err = x.stdout.decode(errors="ignore") + "\n" + x.stderr.decode(errors="ignore")

            ## record err to GDB_OUTPUT_FOLDER
            if not os.path.isdir(GDB_OUTPUT_FOLDER):  # GDBOutput/jhead/jhead_1_0/
                os.makedirs(GDB_OUTPUT_FOLDER, exist_ok=True)
            with open(os.path.join(GDB_OUTPUT_FOLDER, line_crashes + ".stdout"), "wb") as errfp:
                errfp.write(x.stdout)
            with open(os.path.join(GDB_OUTPUT_FOLDER, line_crashes + ".stderr"), "wb") as errfp:
                errfp.write(x.stderr)
            open(os.path.join(GDB_OUTPUT_FOLDER, line_crashes + ".timeouted"), "wb").write(b'1')
            # with open("gdbtimeout_{fuzzername}_{prog}.log".format(**locals()), "a") as tmp:
            #    tmp.write(line+"\n")
            print(' =======================[timeout file writing] =============================')


            if "\nShort description: " in err:
                print("%.1f" % (100 * T / total_lines), line.split('\n')[0])  # %.1f，保留1位小数 , %作用：格式化字符串
        except Exception as e:
            traceback.print_exc()
            print('出现异常并写入gdbrunner_error.log日志文件：', str(e))  # gdb运行错误（异常）才执行
            open(os.path.join(GDB_OUTPUT_FOLDER,"gdbrunner_error.log"), "a").write(line.split("\n")[0] + "\t" + str(e) + "\n")